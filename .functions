#!/bin/sh

# Create a new directory and enter it
function md() {
  mkdir -p "$@" && cd "$@"
}

# List all files, long format, colorized, permissions in octal
function la(){
  ls -l  "$@" | awk '
    {
      k=0;
      for (i=0;i<=8;i++)
        k+=((substr($1,i+2,1)~/[rwx]/) *2^(8-i));
      if (k)
        printf("%0o ",k);
      printf(" %9s  %3s %2s %5s  %6s  %s %s %s\n", $3, $6, $7, $8, $5, $9,$10, $11);
    }'
}

log() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index --toggle-sort=\` \
      --bind "ctrl-m:execute:
                echo '{}' | grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R'"
}

function c() {
  # This lets you quickly jump into a project directory.
  #
  # Type:
  #
  #   c <tab>
  #
  # ...to autocomplete on all of your projects in the directories specified in
  # `functions/_c`. Typically I'm using it like:
  #
  #    c holm<tab>/bo<tab>
  #
  # ...to quickly jump into holman/boom, for example.
  #
  # This also accounts for how Go structures its projects. For example, it will
  # autocomplete both on $PROJECTS, and also assume you want to autocomplete on
  # your Go projects in $GOPATH/src.

  if [ ! -z "$1" ] && [ -s "$GOPATH/src/github.com/$1" ]; then
    cd "$GOPATH/src/github.com/$1"
  else
    cd "$PROJECTS/$1"
  fi
}

function e() {
  # Quick shortcut to an editor.
  #
  # This means that as I travel back and forth between editors, hey, I don't have
  # to re-learn any arcane commands. Neat.
  #
  # USAGE:
  #
  #   $ e
  #   # => opens the current directory in your editor
  #
  #   $ e .
  #   $ e /usr/local
  #   # => opens the specified directory in your editor

  if [ "$1" = "" ] ; then
    exec $EDITOR .
  else
    exec $EDITOR "$1"
  fi
}

function ea() {
  # Quick shortcut to an editor.
  #
  # This means that as I travel back and forth between editors, hey, I don't have
  # to re-learn any arcane commands. Neat.
  #
  # NOTE: maybe this only works for sublime, but ea is like e but adds it to your open editor
  #
  # USAGE:
  #
  #   $ ea
  #   # => opens the current directory in your currently open editor
  #
  #   $ ea .
  #   $ ea /usr/local
  #   # => opens the specified directory in your currently openeditor

  if [ "$1" = "" ] ; then
    exec $EDITOR -a .
  else
    exec $EDITOR -a "$1"
  fi
}

git-track() {
  # Sets up your branch to track a remote branch. Assumes you mean
  # `origin/$branch-name`.

  branch=$(git rev-parse --abbrev-ref HEAD)
  git branch $branch --set-upstream-to origin/$branch
}

clean_docker() {
  #!/bin/bash

  # Copyright 2017 ThÃ©o Chamley
  # Permission is hereby granted, free of charge, to any person obtaining a copy of
  # this software and associated documentation files (the "Software"), to deal in the Software
  # without restriction, including without limitation the rights to use, copy, modify, merge,
  # publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
  # to whom the Software is furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all copies or
  # substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
  # BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  # DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

  IMAGES=$@

  echo "This will remove all your current containers and images except for:"
  echo ${IMAGES}
  read -p "Are you sure? [yes/NO] " -n 1 -r
  echo    # (optional) move to a new line
  if [[ ! $REPLY =~ ^[Yy]$ ]]
  then
      exit 1
  fi


  TMP_DIR=$(mktemp -d)

  pushd $TMP_DIR >/dev/null

  open -a Docker
  echo "=> Saving the specified images"
  for image in ${IMAGES}; do
    echo "==> Saving ${image}"
    tar=$(echo -n ${image} | base64)
    docker save -o ${tar}.tar ${image}
    echo "==> Done."
  done

  echo "=> Cleaning up"
  echo -n "==> Quiting Docker"
  osascript -e 'quit app "Docker"'
  while docker info >/dev/null 2>&1; do
    echo -n "."
    sleep 1
  done;
  echo ""

  echo "==> Removing Docker.qcow2 file"
  rm ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/Docker.qcow2

  echo "==> Launching Docker"
  open -a Docker
  echo -n "==> Waiting for Docker to start"
  until docker info >/dev/null 2>&1; do
    echo -n "."
    sleep 1
  done;
  echo ""

  echo "=> Done."

  echo "=> Loading saved images"
  for image in ${IMAGES}; do
    echo "==> Loading ${image}"
    tar=$(echo -n ${image} | base64)
    docker load -q -i ${tar}.tar || exit 1
    echo "==> Done."
  done

  popd >/dev/null
  rm -r ${TMP_DIR}

}
